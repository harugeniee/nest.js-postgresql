import { User } from 'src/users/entities/user.entity';
import {
  Entity,
  Column,
  Index,
  ManyToOne,
  JoinColumn,
  OneToMany,
} from 'typeorm';
import { BaseEntityCustom } from 'src/shared/entities/base.entity';
import { ReportAction } from './report-action.entity';
import {
  REPORT_CONSTANTS,
  ReportStatus,
  ReportPriority,
  ReportableType,
  ReportReason,
  ReportAction as ReportActionType,
  ReportResolution,
} from 'src/shared/constants';

/**
 * Report Entity
 *
 * Stores user reports for various content types (articles, comments, users, etc.)
 * Similar to reporting systems in social media platforms like TikTok, Facebook
 */
@Entity('reports')
@Index(['reportableType', 'reportableId'])
@Index(['userId'])
@Index(['status'])
@Index(['priority'])
@Index(['reason'])
export class Report extends BaseEntityCustom {
  /**
   * ID of the user who submitted the report
   * Links to users table
   */
  @Column({ type: 'bigint', nullable: false })
  userId: string;

  /**
   * User who submitted the report
   * Many-to-One relationship with User entity
   */
  @ManyToOne(() => User, { nullable: false })
  @JoinColumn({ name: 'userId', referencedColumnName: 'id' })
  user: User;

  /**
   * Type of content being reported
   * Examples: 'article', 'comment', 'user', 'media', 'sticker'
   */
  @Column({
    type: 'varchar',
    length: 50,
    nullable: false,
  })
  reportableType: ReportableType;

  /**
   * ID of the content being reported
   * References the ID of the reported content
   */
  @Column({ type: 'bigint', nullable: false })
  reportableId: string;

  /**
   * Reason for the report
   * Examples: 'spam', 'harassment', 'hate_speech', 'inappropriate_content'
   */
  @Column({
    type: 'varchar',
    length: REPORT_CONSTANTS.REASON_MAX_LENGTH,
    nullable: false,
  })
  reason: ReportReason;

  /**
   * Additional description provided by the reporter
   * Optional detailed explanation of the report
   */
  @Column({
    type: 'text',
    nullable: true,
  })
  description?: string;

  /**
   * Current status of the report
   * Examples: 'pending', 'under_review', 'resolved', 'dismissed'
   */
  @Column({
    type: 'varchar',
    length: 20,
    default: REPORT_CONSTANTS.STATUS.PENDING,
    nullable: false,
  })
  status: ReportStatus;

  /**
   * Priority level of the report
   * Examples: 'low', 'medium', 'high', 'urgent'
   */
  @Column({
    type: 'varchar',
    length: 10,
    default: REPORT_CONSTANTS.PRIORITY.MEDIUM,
    nullable: false,
  })
  priority: ReportPriority;

  /**
   * ID of the moderator assigned to review this report
   * Links to users table (moderator)
   */
  @Column({ type: 'bigint', nullable: true })
  moderatorId?: string;

  /**
   * Moderator assigned to review this report
   * Many-to-One relationship with User entity
   */
  @ManyToOne(() => User, { nullable: true })
  @JoinColumn({ name: 'moderatorId', referencedColumnName: 'id' })
  moderator?: User;

  /**
   * Action taken by the moderator
   * Examples: 'no_action', 'content_removed', 'user_warned', 'user_banned'
   */
  @Column({
    type: 'varchar',
    length: REPORT_CONSTANTS.ACTION_MAX_LENGTH,
    nullable: true,
  })
  action?: ReportActionType;

  /**
   * Notes from the moderator about the report
   * Internal notes for moderation team
   */
  @Column({
    type: 'text',
    nullable: true,
  })
  moderatorNotes?: string;

  /**
   * Resolution of the report
   * Examples: 'resolved', 'dismissed', 'escalated'
   */
  @Column({
    type: 'varchar',
    length: 20,
    nullable: true,
  })
  resolution?: ReportResolution;

  /**
   * Additional details about the resolution
   * Explanation of how the report was resolved
   */
  @Column({
    type: 'text',
    nullable: true,
  })
  resolutionDetails?: string;

  /**
   * Timestamp when the report was assigned to a moderator
   * Null if not yet assigned
   */
  @Column({
    type: 'timestamp',
    nullable: true,
  })
  assignedAt?: Date;

  /**
   * Timestamp when the report was resolved
   * Null if not yet resolved
   */
  @Column({
    type: 'timestamp',
    nullable: true,
  })
  resolvedAt?: Date;

  /**
   * Number of similar reports for the same content
   * Used for auto-escalation and pattern detection
   */
  @Column({
    type: 'int',
    default: 1,
    nullable: false,
  })
  duplicateCount: number;

  /**
   * Whether this report was automatically generated
   * True for system-generated reports (e.g., spam detection)
   */
  @Column({
    type: 'boolean',
    default: false,
    nullable: false,
  })
  isAutoGenerated: boolean;

  /**
   * Additional metadata for the report
   * JSON field for storing report-specific data
   */
  @Column({
    type: 'jsonb',
    nullable: true,
  })
  metadata?: Record<string, any>;

  /**
   * Report actions taken by moderators
   * One-to-Many relationship with ReportAction entity
   */
  @OneToMany(() => ReportAction, (action) => action.report, {
    cascade: true,
  })
  actions: ReportAction[];

  /**
   * Check if the report is pending review
   * @returns {boolean} True if status is pending
   */
  isPending(): boolean {
    return this.status === REPORT_CONSTANTS.STATUS.PENDING;
  }

  /**
   * Check if the report is under review
   * @returns {boolean} True if status is under_review
   */
  isUnderReview(): boolean {
    return this.status === REPORT_CONSTANTS.STATUS.UNDER_REVIEW;
  }

  /**
   * Check if the report is resolved
   * @returns {boolean} True if status is resolved
   */
  isResolved(): boolean {
    return this.status === REPORT_CONSTANTS.STATUS.RESOLVED;
  }

  /**
   * Check if the report is dismissed
   * @returns {boolean} True if status is dismissed
   */
  isDismissed(): boolean {
    return this.status === REPORT_CONSTANTS.STATUS.DISMISSED;
  }

  /**
   * Check if the report is escalated
   * @returns {boolean} True if status is escalated
   */
  isEscalated(): boolean {
    return this.status === REPORT_CONSTANTS.STATUS.ESCALATED;
  }

  /**
   * Check if the report is high priority
   * @returns {boolean} True if priority is high or urgent
   */
  isHighPriority(): boolean {
    return (
      this.priority === REPORT_CONSTANTS.PRIORITY.HIGH ||
      this.priority === REPORT_CONSTANTS.PRIORITY.URGENT
    );
  }

  /**
   * Check if the report is urgent
   * @returns {boolean} True if priority is urgent
   */
  isUrgent(): boolean {
    return this.priority === REPORT_CONSTANTS.PRIORITY.URGENT;
  }

  /**
   * Get the report age in days
   * @returns {number} Number of days since report creation
   */
  getAgeInDays(): number {
    const now = new Date();
    const diffTime = Math.abs(now.getTime() - this.createdAt.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  /**
   * Check if the report is expired (older than 30 days and pending)
   * @returns {boolean} True if report is expired
   */
  isExpired(): boolean {
    return (
      this.isPending() &&
      this.getAgeInDays() > REPORT_CONSTANTS.EXPIRATION.PENDING_DAYS
    );
  }
}
