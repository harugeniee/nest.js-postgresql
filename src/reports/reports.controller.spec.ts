import { Test, TestingModule } from '@nestjs/testing';
import { HttpException, HttpStatus } from '@nestjs/common';
import { ReportsController } from './reports.controller';
import { ReportsService } from './reports.service';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { QueryReportsDto } from './dto/query-reports.dto';
import { CreateReportActionDto } from './dto/create-report-action.dto';
import { ReportStatsDto } from './dto/report-stats.dto';
import { AssignReportDto } from './dto/assign-report.dto';
import { ResolveReportDto } from './dto/resolve-report.dto';
import { DismissReportDto } from './dto/dismiss-report.dto';
import { EscalateReportDto } from './dto/escalate-report.dto';
import { MergeReportsDto } from './dto/merge-reports.dto';
import { JwtAccessTokenGuard, RolesGuard } from 'src/auth/guard';
import { JwtService } from '@nestjs/jwt';
import { CacheService } from 'src/shared/services';
import { ConfigService } from '@nestjs/config';

describe('ReportsController', () => {
  let controller: ReportsController;
  let service: ReportsService;

  const mockReport = {
    id: '1',
    userId: '1',
    user: {
      id: '1',
      username: 'testuser',
      displayName: 'Test User',
      avatar: 'avatar.jpg',
    },
    reportableType: 'article',
    reportableId: '1',
    reason: 'spam',
    description: 'This is spam content',
    status: 'pending',
    priority: 'medium',
    moderatorId: null,
    moderator: null,
    action: null,
    moderatorNotes: null,
    resolution: null,
    resolutionDetails: null,
    assignedAt: null,
    resolvedAt: null,
    duplicateCount: 1,
    isAutoGenerated: false,
    metadata: {},
    actions: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const mockReportAction = {
    id: '1',
    reportId: '1',
    report: mockReport,
    moderatorId: '2',
    moderator: {
      id: '2',
      username: 'moderator',
      displayName: 'Moderator',
    },
    action: 'content_removed',
    description: 'Content removed due to spam',
    notes: 'User warned about future violations',
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ReportsController],
      providers: [
        {
          provide: ReportsService,
          useValue: {
            createReport: jest.fn(),
            updateReport: jest.fn(),
            list: jest.fn(),
            getById: jest.fn(),
            createReportAction: jest.fn(),
            getStats: jest.fn(),
            assignReport: jest.fn(),
            resolveReport: jest.fn(),
            dismissReport: jest.fn(),
            escalateReport: jest.fn(),
            getReportsForContent: jest.fn(),
            getDuplicateReports: jest.fn(),
            mergeDuplicateReports: jest.fn(),
          },
        },
        {
          provide: JwtAccessTokenGuard,
          useValue: {
            canActivate: jest.fn().mockReturnValue(true),
          },
        },
        {
          provide: RolesGuard,
          useValue: {
            canActivate: jest.fn().mockReturnValue(true),
          },
        },
        {
          provide: JwtService,
          useValue: {
            verify: jest.fn(),
            sign: jest.fn(),
          },
        },
        {
          provide: CacheService,
          useValue: {
            get: jest.fn(),
            set: jest.fn(),
            delete: jest.fn(),
          },
        },
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<ReportsController>(ReportsController);
    service = module.get<ReportsService>(ReportsService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('createReport', () => {
    it('should create a new report successfully', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
        description: 'This is spam content',
        priority: 'medium',
      };

      jest.spyOn(service, 'createReport').mockResolvedValue(mockReport as any);

      const result = await controller.createReport(req, dto);

      expect(result).toEqual(mockReport);
      expect(service.createReport).toHaveBeenCalledWith('1', dto);
    });

    it('should create a report with auto-generated flag', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: CreateReportDto = {
        reportableType: 'comment',
        reportableId: '2',
        reason: 'hate_speech',
        description: 'Automatically detected hate speech',
        isAutoGenerated: true,
        priority: 'high',
      };

      const autoGeneratedReport = { ...mockReport, isAutoGenerated: true };
      jest
        .spyOn(service, 'createReport')
        .mockResolvedValue(autoGeneratedReport as any);

      const result = await controller.createReport(req, dto);

      expect(result).toEqual(autoGeneratedReport);
      expect(service.createReport).toHaveBeenCalledWith('1', dto);
    });

    it('should handle service errors when creating report', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
      };

      const error = new HttpException('Duplicate report', HttpStatus.CONFLICT);
      jest.spyOn(service, 'createReport').mockRejectedValue(error);

      await expect(controller.createReport(req, dto)).rejects.toThrow(error);
    });
  });

  describe('getReports', () => {
    it('should return paginated reports with filters', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
        status: 'pending',
        priority: 'high',
        reportableType: 'article',
        reason: 'spam',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getReports(dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith(dto);
    });

    it('should return empty result when no reports found', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
        status: 'resolved',
      };

      const mockResult = {
        result: [],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 0,
          totalPages: 0,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getReports(dto);

      expect(result).toEqual(mockResult);
      expect(result.result).toHaveLength(0);
    });

    it('should handle service errors when getting reports', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'list').mockRejectedValue(error);

      await expect(controller.getReports(dto)).rejects.toThrow(error);
    });
  });

  describe('getReport', () => {
    it('should return a single report by ID', async () => {
      const reportId = '1';

      jest.spyOn(service, 'getById').mockResolvedValue(mockReport as any);

      const result = await controller.getReport(reportId);

      expect(result).toEqual(mockReport);
      expect(service.getById).toHaveBeenCalledWith(reportId);
    });

    it('should throw error when report not found', async () => {
      const reportId = 'nonexistent';

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'getById').mockRejectedValue(error);

      await expect(controller.getReport(reportId)).rejects.toThrow(error);
    });

    it('should handle invalid report ID format', async () => {
      const reportId = 'invalid-id';

      const error = new HttpException(
        'Invalid ID format',
        HttpStatus.BAD_REQUEST,
      );
      jest.spyOn(service, 'getById').mockRejectedValue(error);

      await expect(controller.getReport(reportId)).rejects.toThrow(error);
    });
  });

  describe('updateReport', () => {
    it('should update a report successfully', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: UpdateReportDto = {
        status: 'under_review',
        priority: 'high',
        moderatorId: '2',
      };

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport as any);

      const result = await controller.updateReport(reportId, req, dto);

      expect(result).toEqual(mockReport);
      expect(service.updateReport).toHaveBeenCalledWith(reportId, '2', dto);
    });

    it('should update report with resolution details', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: UpdateReportDto = {
        status: 'resolved',
        action: 'content_removed',
        resolution: 'resolved',
        resolutionDetails: 'Content removed and user warned',
        moderatorNotes: 'User warned about future violations',
        resolvedAt: new Date(),
      };

      const resolvedReport = {
        ...mockReport,
        status: 'resolved',
        action: 'content_removed',
      };
      jest
        .spyOn(service, 'updateReport')
        .mockResolvedValue(resolvedReport as any);

      const result = await controller.updateReport(reportId, req, dto);

      expect(result).toEqual(resolvedReport);
      expect(service.updateReport).toHaveBeenCalledWith(reportId, '2', dto);
    });

    it('should handle service errors when updating report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: UpdateReportDto = {
        status: 'under_review',
      };

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'updateReport').mockRejectedValue(error);

      await expect(controller.updateReport(reportId, req, dto)).rejects.toThrow(
        error,
      );
    });
  });

  describe('assignReport', () => {
    it('should assign a report to a moderator successfully', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: AssignReportDto = { moderatorId: '3' };

      jest.spyOn(service, 'assignReport').mockResolvedValue(mockReport as any);

      const result = await controller.assignReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.assignReport).toHaveBeenCalledWith(reportId, '3');
    });

    it('should handle service errors when assigning report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: AssignReportDto = { moderatorId: '3' };

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'assignReport').mockRejectedValue(error);

      await expect(
        controller.assignReport(reportId, req, body),
      ).rejects.toThrow(error);
    });

    it('should handle invalid moderator ID', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: AssignReportDto = { moderatorId: 'invalid-id' };

      const error = new HttpException(
        'Invalid moderator ID',
        HttpStatus.BAD_REQUEST,
      );
      jest.spyOn(service, 'assignReport').mockRejectedValue(error);

      await expect(
        controller.assignReport(reportId, req, body),
      ).rejects.toThrow(error);
    });
  });

  describe('resolveReport', () => {
    it('should resolve a report successfully', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: ResolveReportDto = {
        action: 'content_removed',
        resolution: 'resolved',
        resolutionDetails: 'Content removed and user warned',
        moderatorNotes: 'User warned about future violations',
      };

      jest.spyOn(service, 'resolveReport').mockResolvedValue(mockReport as any);

      const result = await controller.resolveReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.resolveReport).toHaveBeenCalledWith(reportId, '2', body);
    });

    it('should resolve report with minimal data', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: ResolveReportDto = {
        action: 'no_action',
        resolution: 'dismissed',
      };

      const resolvedReport = {
        ...mockReport,
        status: 'resolved',
        action: 'no_action',
      };
      jest
        .spyOn(service, 'resolveReport')
        .mockResolvedValue(resolvedReport as any);

      const result = await controller.resolveReport(reportId, req, body);

      expect(result).toEqual(resolvedReport);
      expect(service.resolveReport).toHaveBeenCalledWith(reportId, '2', body);
    });

    it('should handle service errors when resolving report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: ResolveReportDto = {
        action: 'content_removed',
        resolution: 'resolved',
      };

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'resolveReport').mockRejectedValue(error);

      await expect(
        controller.resolveReport(reportId, req, body),
      ).rejects.toThrow(error);
    });
  });

  describe('dismissReport', () => {
    it('should dismiss a report successfully', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: DismissReportDto = { reason: 'No violation found' };

      jest.spyOn(service, 'dismissReport').mockResolvedValue(mockReport as any);

      const result = await controller.dismissReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.dismissReport).toHaveBeenCalledWith(
        reportId,
        '2',
        'No violation found',
      );
    });

    it('should handle service errors when dismissing report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: DismissReportDto = { reason: 'No violation found' };

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'dismissReport').mockRejectedValue(error);

      await expect(
        controller.dismissReport(reportId, req, body),
      ).rejects.toThrow(error);
    });

    it('should dismiss report with detailed reason', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: DismissReportDto = {
        reason:
          'Content does not violate community guidelines. User was expressing legitimate opinion.',
      };

      const dismissedReport = { ...mockReport, status: 'dismissed' };
      jest
        .spyOn(service, 'dismissReport')
        .mockResolvedValue(dismissedReport as any);

      const result = await controller.dismissReport(reportId, req, body);

      expect(result).toEqual(dismissedReport);
      expect(service.dismissReport).toHaveBeenCalledWith(
        reportId,
        '2',
        body.reason,
      );
    });
  });

  describe('escalateReport', () => {
    it('should escalate a report successfully', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: EscalateReportDto = { reason: 'Requires admin review' };

      jest
        .spyOn(service, 'escalateReport')
        .mockResolvedValue(mockReport as any);

      const result = await controller.escalateReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.escalateReport).toHaveBeenCalledWith(
        reportId,
        '2',
        'Requires admin review',
      );
    });

    it('should handle service errors when escalating report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: EscalateReportDto = { reason: 'Requires admin review' };

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'escalateReport').mockRejectedValue(error);

      await expect(
        controller.escalateReport(reportId, req, body),
      ).rejects.toThrow(error);
    });

    it('should escalate report with detailed reason', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body: EscalateReportDto = {
        reason:
          'Complex case involving multiple violations. Requires senior moderator review and potential legal consultation.',
      };

      const escalatedReport = { ...mockReport, status: 'escalated' };
      jest
        .spyOn(service, 'escalateReport')
        .mockResolvedValue(escalatedReport as any);

      const result = await controller.escalateReport(reportId, req, body);

      expect(result).toEqual(escalatedReport);
      expect(service.escalateReport).toHaveBeenCalledWith(
        reportId,
        '2',
        body.reason,
      );
    });
  });

  describe('createReportAction', () => {
    it('should create a report action successfully', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: Omit<CreateReportActionDto, 'reportId'> = {
        action: 'content_removed',
        description: 'Content removed due to spam',
        notes: 'User warned about future violations',
      };

      jest
        .spyOn(service, 'createReportAction')
        .mockResolvedValue(mockReportAction as any);

      const result = await controller.createReportAction(reportId, req, dto);

      expect(result).toEqual(mockReportAction);
      expect(service.createReportAction).toHaveBeenCalledWith('2', {
        ...dto,
        reportId,
      });
    });

    it('should create report action with metadata', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: Omit<CreateReportActionDto, 'reportId'> = {
        action: 'user_warned',
        description: 'User warned about inappropriate behavior',
        notes: 'First warning issued',
        metadata: {
          warningLevel: 1,
          previousWarnings: 0,
          contentId: '123',
        },
      };

      const actionWithMetadata = {
        ...mockReportAction,
        metadata: dto.metadata,
      };
      jest
        .spyOn(service, 'createReportAction')
        .mockResolvedValue(actionWithMetadata as any);

      const result = await controller.createReportAction(reportId, req, dto);

      expect(result).toEqual(actionWithMetadata);
      expect(service.createReportAction).toHaveBeenCalledWith('2', {
        ...dto,
        reportId,
      });
    });

    it('should handle service errors when creating report action', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: Omit<CreateReportActionDto, 'reportId'> = {
        action: 'content_removed',
      };

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'createReportAction').mockRejectedValue(error);

      await expect(
        controller.createReportAction(reportId, req, dto),
      ).rejects.toThrow(error);
    });
  });

  describe('getReportsForContent', () => {
    it('should return reports for specific content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      jest
        .spyOn(service, 'getReportsForContent')
        .mockResolvedValue([mockReport] as any);

      const result = await controller.getReportsForContent(
        reportableType,
        reportableId,
      );

      expect(result).toEqual([mockReport]);
      expect(service.getReportsForContent).toHaveBeenCalledWith(
        reportableType,
        reportableId,
      );
    });

    it('should return empty array when no reports found for content', async () => {
      const reportableType = 'comment';
      const reportableId = '999';

      jest.spyOn(service, 'getReportsForContent').mockResolvedValue([] as any);

      const result = await controller.getReportsForContent(
        reportableType,
        reportableId,
      );

      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });

    it('should handle service errors when getting reports for content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'getReportsForContent').mockRejectedValue(error);

      await expect(
        controller.getReportsForContent(reportableType, reportableId),
      ).rejects.toThrow(error);
    });
  });

  describe('getDuplicateReports', () => {
    it('should return duplicate reports for content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      jest
        .spyOn(service, 'getDuplicateReports')
        .mockResolvedValue([mockReport] as any);

      const result = await controller.getDuplicateReports(
        reportableType,
        reportableId,
      );

      expect(result).toEqual([mockReport]);
      expect(service.getDuplicateReports).toHaveBeenCalledWith(
        reportableType,
        reportableId,
      );
    });

    it('should return empty array when no duplicate reports found', async () => {
      const reportableType = 'comment';
      const reportableId = '999';

      jest.spyOn(service, 'getDuplicateReports').mockResolvedValue([] as any);

      const result = await controller.getDuplicateReports(
        reportableType,
        reportableId,
      );

      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });

    it('should handle service errors when getting duplicate reports', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'getDuplicateReports').mockRejectedValue(error);

      await expect(
        controller.getDuplicateReports(reportableType, reportableId),
      ).rejects.toThrow(error);
    });
  });

  describe('mergeDuplicateReports', () => {
    it('should merge duplicate reports successfully', async () => {
      const req = { user: { uid: '2' } } as any;
      const body: MergeReportsDto = { reportIds: ['1', '2', '3'] };

      jest
        .spyOn(service, 'mergeDuplicateReports')
        .mockResolvedValue(mockReport as any);

      const result = await controller.mergeDuplicateReports(req, body);

      expect(result).toEqual(mockReport);
      expect(service.mergeDuplicateReports).toHaveBeenCalledWith(
        ['1', '2', '3'],
        '2',
      );
    });

    it('should handle service errors when merging reports', async () => {
      const req = { user: { uid: '2' } } as any;
      const body: MergeReportsDto = { reportIds: ['1', '2', '3'] };

      const error = new HttpException(
        'Insufficient reports to merge',
        HttpStatus.BAD_REQUEST,
      );
      jest.spyOn(service, 'mergeDuplicateReports').mockRejectedValue(error);

      await expect(controller.mergeDuplicateReports(req, body)).rejects.toThrow(
        error,
      );
    });

    it('should handle invalid report IDs when merging', async () => {
      const req = { user: { uid: '2' } } as any;
      const body: MergeReportsDto = { reportIds: ['invalid', '2', '3'] };

      const error = new HttpException(
        'Invalid report IDs',
        HttpStatus.BAD_REQUEST,
      );
      jest.spyOn(service, 'mergeDuplicateReports').mockRejectedValue(error);

      await expect(controller.mergeDuplicateReports(req, body)).rejects.toThrow(
        error,
      );
    });

    it('should handle insufficient reports for merging', async () => {
      const req = { user: { uid: '2' } } as any;
      const body: MergeReportsDto = { reportIds: ['1'] };

      const error = new HttpException(
        'At least 2 reports required for merging',
        HttpStatus.BAD_REQUEST,
      );
      jest.spyOn(service, 'mergeDuplicateReports').mockRejectedValue(error);

      await expect(controller.mergeDuplicateReports(req, body)).rejects.toThrow(
        error,
      );
    });
  });

  describe('getReportStats', () => {
    it('should return report statistics with filters', async () => {
      const dto: ReportStatsDto = {
        status: 'pending',
        startDate: '2024-01-01T00:00:00Z',
        endDate: '2024-12-31T23:59:59Z',
        groupBy: 'day',
      };

      const mockStats = {
        totalReports: 10,
        pendingReports: 5,
        underReviewReports: 3,
        resolvedReports: 2,
        dismissedReports: 0,
        escalatedReports: 0,
        reportsByStatus: { pending: 5, under_review: 3, resolved: 2 },
        reportsByPriority: { low: 2, medium: 5, high: 3 },
        reportsByType: { article: 8, comment: 2 },
        reportsByReason: { spam: 6, harassment: 4 },
        averageResolutionTime: 2.5,
        topUsers: [{ userId: '1', count: 3 }],
        topModerators: [{ moderatorId: '2', count: 5 }],
        recentTrends: [{ date: '2024-01-15', count: 2 }],
      };

      jest.spyOn(service, 'getStats').mockResolvedValue(mockStats as any);

      const result = await controller.getReportStats(dto);

      expect(result).toEqual(mockStats);
      expect(service.getStats).toHaveBeenCalledWith(dto);
    });

    it('should return statistics without filters', async () => {
      const dto: ReportStatsDto = {};

      const mockStats = {
        totalReports: 100,
        pendingReports: 20,
        underReviewReports: 15,
        resolvedReports: 50,
        dismissedReports: 10,
        escalatedReports: 5,
        reportsByStatus: {
          pending: 20,
          under_review: 15,
          resolved: 50,
          dismissed: 10,
          escalated: 5,
        },
        reportsByPriority: { low: 30, medium: 40, high: 25, urgent: 5 },
        reportsByType: { article: 60, comment: 30, user: 10 },
        reportsByReason: {
          spam: 40,
          harassment: 25,
          hate_speech: 20,
          other: 15,
        },
        averageResolutionTime: 1.5,
        topUsers: [{ userId: '1', count: 10 }],
        topModerators: [{ moderatorId: '2', count: 25 }],
        recentTrends: [{ date: '2024-01-15', count: 5 }],
      };

      jest.spyOn(service, 'getStats').mockResolvedValue(mockStats as any);

      const result = await controller.getReportStats(dto);

      expect(result).toEqual(mockStats);
      expect(service.getStats).toHaveBeenCalledWith(dto);
    });

    it('should handle service errors when getting statistics', async () => {
      const dto: ReportStatsDto = {
        status: 'pending',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'getStats').mockRejectedValue(error);

      await expect(controller.getReportStats(dto)).rejects.toThrow(error);
    });
  });

  describe('getMyReports', () => {
    it('should return user reports with filters', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: Omit<QueryReportsDto, 'userId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
        status: 'pending',
        priority: 'high',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getMyReports(req, dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, userId: '1' });
    });

    it('should return empty result when user has no reports', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: Omit<QueryReportsDto, 'userId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 0,
          totalPages: 0,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getMyReports(req, dto);

      expect(result).toEqual(mockResult);
      expect(result.result).toHaveLength(0);
    });

    it('should handle service errors when getting user reports', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: Omit<QueryReportsDto, 'userId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'list').mockRejectedValue(error);

      await expect(controller.getMyReports(req, dto)).rejects.toThrow(error);
    });
  });

  describe('getAssignedReports', () => {
    it('should return reports assigned to moderator', async () => {
      const req = { user: { uid: '2' } } as any;
      const dto: Omit<QueryReportsDto, 'moderatorId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getAssignedReports(req, dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, moderatorId: '2' });
    });

    it('should return empty result when no reports assigned', async () => {
      const req = { user: { uid: '2' } } as any;
      const dto: Omit<QueryReportsDto, 'moderatorId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 0,
          totalPages: 0,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getAssignedReports(req, dto);

      expect(result).toEqual(mockResult);
      expect(result.result).toHaveLength(0);
    });

    it('should handle service errors when getting assigned reports', async () => {
      const req = { user: { uid: '2' } } as any;
      const dto: Omit<QueryReportsDto, 'moderatorId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'list').mockRejectedValue(error);

      await expect(controller.getAssignedReports(req, dto)).rejects.toThrow(
        error,
      );
    });
  });

  describe('getPendingReports', () => {
    it('should return pending reports', async () => {
      const dto: Omit<QueryReportsDto, 'status'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getPendingReports(dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, status: 'pending' });
    });

    it('should return empty result when no pending reports', async () => {
      const dto: Omit<QueryReportsDto, 'status'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 0,
          totalPages: 0,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getPendingReports(dto);

      expect(result).toEqual(mockResult);
      expect(result.result).toHaveLength(0);
    });

    it('should handle service errors when getting pending reports', async () => {
      const dto: Omit<QueryReportsDto, 'status'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'list').mockRejectedValue(error);

      await expect(controller.getPendingReports(dto)).rejects.toThrow(error);
    });
  });

  describe('getUrgentReports', () => {
    it('should return urgent reports', async () => {
      const dto: Omit<QueryReportsDto, 'priority'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getUrgentReports(dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, priority: 'urgent' });
    });

    it('should return empty result when no urgent reports', async () => {
      const dto: Omit<QueryReportsDto, 'priority'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 0,
          totalPages: 0,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getUrgentReports(dto);

      expect(result).toEqual(mockResult);
      expect(result.result).toHaveLength(0);
    });

    it('should handle service errors when getting urgent reports', async () => {
      const dto: Omit<QueryReportsDto, 'priority'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service, 'list').mockRejectedValue(error);

      await expect(controller.getUrgentReports(dto)).rejects.toThrow(error);
    });
  });
});
