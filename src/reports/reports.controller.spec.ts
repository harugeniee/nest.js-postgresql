import { Test, TestingModule } from '@nestjs/testing';
import { ReportsController } from './reports.controller';
import { ReportsService } from './reports.service';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { QueryReportsDto } from './dto/query-reports.dto';
import { CreateReportActionDto } from './dto/create-report-action.dto';
import { ReportStatsDto } from './dto/report-stats.dto';
import { JwtAccessTokenGuard } from 'src/auth/guard';
import { RoleGuard } from 'src/auth/guard/role.guard';
import { JwtService } from '@nestjs/jwt';
import { CacheService } from 'src/shared/services';
import { ConfigService } from '@nestjs/config';

describe('ReportsController', () => {
  let controller: ReportsController;
  let service: ReportsService;

  const mockReport = {
    id: '1',
    reporterId: '1',
    reporter: {
      id: '1',
      username: 'testuser',
      displayName: 'Test User',
      avatar: 'avatar.jpg',
    },
    reportableType: 'article',
    reportableId: '1',
    reason: 'spam',
    description: 'This is spam content',
    status: 'pending',
    priority: 'medium',
    moderatorId: null,
    moderator: null,
    action: null,
    moderatorNotes: null,
    resolution: null,
    resolutionDetails: null,
    assignedAt: null,
    resolvedAt: null,
    duplicateCount: 1,
    isAutoGenerated: false,
    metadata: {},
    actions: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const mockReportAction = {
    id: '1',
    reportId: '1',
    report: mockReport,
    moderatorId: '2',
    moderator: {
      id: '2',
      username: 'moderator',
      displayName: 'Moderator',
    },
    action: 'content_removed',
    description: 'Content removed due to spam',
    notes: 'User warned about future violations',
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ReportsController],
      providers: [
        {
          provide: ReportsService,
          useValue: {
            createReport: jest.fn(),
            updateReport: jest.fn(),
            list: jest.fn(),
            getById: jest.fn(),
            createReportAction: jest.fn(),
            getStats: jest.fn(),
            assignReport: jest.fn(),
            resolveReport: jest.fn(),
            dismissReport: jest.fn(),
            escalateReport: jest.fn(),
            getReportsForContent: jest.fn(),
            getDuplicateReports: jest.fn(),
            mergeDuplicateReports: jest.fn(),
          },
        },
        {
          provide: JwtAccessTokenGuard,
          useValue: {
            canActivate: jest.fn().mockReturnValue(true),
          },
        },
        {
          provide: RoleGuard,
          useValue: {
            canActivate: jest.fn().mockReturnValue(true),
          },
        },
        {
          provide: JwtService,
          useValue: {
            verify: jest.fn(),
            sign: jest.fn(),
          },
        },
        {
          provide: CacheService,
          useValue: {
            get: jest.fn(),
            set: jest.fn(),
            delete: jest.fn(),
          },
        },
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<ReportsController>(ReportsController);
    service = module.get<ReportsService>(ReportsService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('createReport', () => {
    it('should create a new report', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
        description: 'This is spam content',
        priority: 'medium',
      };

      jest
        .spyOn(service, 'createReport')
        .mockResolvedValue(mockReport as any);

      const result = await controller.createReport(req, dto);

      expect(result).toEqual(mockReport);
      expect(service.createReport).toHaveBeenCalledWith('1', dto);
    });
  });

  describe('getReports', () => {
    it('should return paginated reports', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
        status: 'pending',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getReports(dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith(dto);
    });
  });

  describe('getReport', () => {
    it('should return a single report by ID', async () => {
      const reportId = '1';

      jest.spyOn(service, 'getById').mockResolvedValue(mockReport as any);

      const result = await controller.getReport(reportId);

      expect(result).toEqual(mockReport);
      expect(service.getById).toHaveBeenCalledWith(reportId);
    });
  });

  describe('updateReport', () => {
    it('should update a report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: UpdateReportDto = {
        status: 'under_review',
        priority: 'high',
        moderatorId: '2',
      };

      jest
        .spyOn(service, 'updateReport')
        .mockResolvedValue(mockReport as any);

      const result = await controller.updateReport(reportId, req, dto);

      expect(result).toEqual(mockReport);
      expect(service.updateReport).toHaveBeenCalledWith(reportId, '2', dto);
    });
  });

  describe('assignReport', () => {
    it('should assign a report to a moderator', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body = { moderatorId: '3' };

      jest.spyOn(service, 'assignReport').mockResolvedValue(mockReport as any);

      const result = await controller.assignReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.assignReport).toHaveBeenCalledWith(reportId, '3');
    });
  });

  describe('resolveReport', () => {
    it('should resolve a report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body = {
        action: 'content_removed',
        resolution: 'resolved',
        resolutionDetails: 'Content removed and user warned',
        moderatorNotes: 'User warned about future violations',
      };

      jest.spyOn(service, 'resolveReport').mockResolvedValue(mockReport as any);

      const result = await controller.resolveReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.resolveReport).toHaveBeenCalledWith(reportId, '2', body);
    });
  });

  describe('dismissReport', () => {
    it('should dismiss a report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body = { reason: 'No violation found' };

      jest.spyOn(service, 'dismissReport').mockResolvedValue(mockReport as any);

      const result = await controller.dismissReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.dismissReport).toHaveBeenCalledWith(reportId, '2', 'No violation found');
    });
  });

  describe('escalateReport', () => {
    it('should escalate a report', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const body = { reason: 'Requires admin review' };

      jest.spyOn(service, 'escalateReport').mockResolvedValue(mockReport as any);

      const result = await controller.escalateReport(reportId, req, body);

      expect(result).toEqual(mockReport);
      expect(service.escalateReport).toHaveBeenCalledWith(reportId, '2', 'Requires admin review');
    });
  });

  describe('createReportAction', () => {
    it('should create a report action', async () => {
      const req = { user: { uid: '2' } } as any;
      const reportId = '1';
      const dto: Omit<CreateReportActionDto, 'reportId'> = {
        action: 'content_removed',
        description: 'Content removed due to spam',
        notes: 'User warned about future violations',
      };

      jest
        .spyOn(service, 'createReportAction')
        .mockResolvedValue(mockReportAction as any);

      const result = await controller.createReportAction(reportId, req, dto);

      expect(result).toEqual(mockReportAction);
      expect(service.createReportAction).toHaveBeenCalledWith('2', {
        ...dto,
        reportId,
      });
    });
  });

  describe('getReportsForContent', () => {
    it('should return reports for specific content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      jest
        .spyOn(service, 'getReportsForContent')
        .mockResolvedValue([mockReport] as any);

      const result = await controller.getReportsForContent(reportableType, reportableId);

      expect(result).toEqual([mockReport]);
      expect(service.getReportsForContent).toHaveBeenCalledWith(reportableType, reportableId);
    });
  });

  describe('getDuplicateReports', () => {
    it('should return duplicate reports for content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      jest
        .spyOn(service, 'getDuplicateReports')
        .mockResolvedValue([mockReport] as any);

      const result = await controller.getDuplicateReports(reportableType, reportableId);

      expect(result).toEqual([mockReport]);
      expect(service.getDuplicateReports).toHaveBeenCalledWith(reportableType, reportableId);
    });
  });

  describe('mergeDuplicateReports', () => {
    it('should merge duplicate reports', async () => {
      const req = { user: { uid: '2' } } as any;
      const body = { reportIds: ['1', '2', '3'] };

      jest
        .spyOn(service, 'mergeDuplicateReports')
        .mockResolvedValue(mockReport as any);

      const result = await controller.mergeDuplicateReports(req, body);

      expect(result).toEqual(mockReport);
      expect(service.mergeDuplicateReports).toHaveBeenCalledWith(['1', '2', '3'], '2');
    });
  });

  describe('getReportStats', () => {
    it('should return report statistics', async () => {
      const dto: ReportStatsDto = {
        status: 'pending',
        startDate: '2024-01-01T00:00:00Z',
        endDate: '2024-12-31T23:59:59Z',
      };

      const mockStats = {
        totalReports: 10,
        pendingReports: 5,
        underReviewReports: 3,
        resolvedReports: 2,
        dismissedReports: 0,
        escalatedReports: 0,
        reportsByStatus: { pending: 5, under_review: 3, resolved: 2 },
        reportsByPriority: { low: 2, medium: 5, high: 3 },
        reportsByType: { article: 8, comment: 2 },
        reportsByReason: { spam: 6, harassment: 4 },
        averageResolutionTime: 2.5,
        topReporters: [{ reporterId: '1', count: 3 }],
        topModerators: [{ moderatorId: '2', count: 5 }],
        recentTrends: [{ date: '2024-01-15', count: 2 }],
      };

      jest.spyOn(service, 'getStats').mockResolvedValue(mockStats as any);

      const result = await controller.getReportStats(dto);

      expect(result).toEqual(mockStats);
      expect(service.getStats).toHaveBeenCalledWith(dto);
    });
  });

  describe('getMyReports', () => {
    it('should return user reports', async () => {
      const req = { user: { uid: '1' } } as any;
      const dto: Omit<QueryReportsDto, 'reporterId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getMyReports(req, dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, reporterId: '1' });
    });
  });

  describe('getAssignedReports', () => {
    it('should return reports assigned to moderator', async () => {
      const req = { user: { uid: '2' } } as any;
      const dto: Omit<QueryReportsDto, 'moderatorId'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getAssignedReports(req, dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, moderatorId: '2' });
    });
  });

  describe('getPendingReports', () => {
    it('should return pending reports', async () => {
      const dto: Omit<QueryReportsDto, 'status'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getPendingReports(dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, status: 'pending' });
    });
  });

  describe('getUrgentReports', () => {
    it('should return urgent reports', async () => {
      const dto: Omit<QueryReportsDto, 'priority'> = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service, 'list').mockResolvedValue(mockResult as any);

      const result = await controller.getUrgentReports(dto);

      expect(result).toEqual(mockResult);
      expect(service.list).toHaveBeenCalledWith({ ...dto, priority: 'urgent' });
    });
  });
});
