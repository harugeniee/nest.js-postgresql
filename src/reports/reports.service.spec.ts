import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { DataSource } from 'typeorm';
import { ReportsService } from './reports.service';
import { Report } from './entities/report.entity';
import { ReportAction } from './entities/report-action.entity';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { QueryReportsDto } from './dto/query-reports.dto';
import { CreateReportActionDto } from './dto/create-report-action.dto';
import { ReportStatsDto } from './dto/report-stats.dto';
import { CacheService, RabbitMQService } from 'src/shared/services';
import { HttpException } from '@nestjs/common';
import { REPORT_CONSTANTS } from 'src/shared/constants';

describe('ReportsService', () => {
  let service: ReportsService;
  let dataSource: DataSource;
  let cacheService: CacheService;

  const mockReport = {
    id: '1',
    reporterId: '1',
    reporter: {
      id: '1',
      username: 'testuser',
      displayName: 'Test User',
      avatar: 'avatar.jpg',
    },
    reportableType: 'article',
    reportableId: '1',
    reason: 'spam',
    description: 'This is spam content',
    status: 'pending',
    priority: 'medium',
    moderatorId: null,
    moderator: null,
    action: null,
    moderatorNotes: null,
    resolution: null,
    resolutionDetails: null,
    assignedAt: null,
    resolvedAt: null,
    duplicateCount: 1,
    isAutoGenerated: false,
    metadata: {},
    actions: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  } as unknown as Report;

  const mockReportAction = {
    id: '1',
    reportId: '1',
    report: mockReport,
    moderatorId: '2',
    moderator: {
      id: '2',
      username: 'moderator',
      displayName: 'Moderator',
    },
    action: 'content_removed',
    description: 'Content removed due to spam',
    notes: 'User warned about future violations',
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
  } as unknown as ReportAction;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ReportsService,
        {
          provide: getRepositoryToken(Report),
          useValue: {
            findOne: jest.fn(),
            save: jest.fn(),
            update: jest.fn(),
            findAndCount: jest.fn(),
            find: jest.fn(),
            count: jest.fn(),
            createQueryBuilder: jest.fn(() => ({
              select: jest.fn().mockReturnThis(),
              where: jest.fn().mockReturnThis(),
              andWhere: jest.fn().mockReturnThis(),
              groupBy: jest.fn().mockReturnThis(),
              orderBy: jest.fn().mockReturnThis(),
              limit: jest.fn().mockReturnThis(),
              getRawMany: jest.fn(),
              getRawOne: jest.fn(),
            })),
            metadata: {
              columns: [{ propertyName: 'deletedAt' }],
            },
            manager: {
              connection: {
                createQueryRunner: jest.fn(() => ({
                  connect: jest.fn(),
                  startTransaction: jest.fn(),
                  commitTransaction: jest.fn(),
                  rollbackTransaction: jest.fn(),
                  release: jest.fn(),
                  manager: {
                    save: jest.fn(),
                    update: jest.fn(),
                    findOne: jest.fn(),
                    delete: jest.fn(),
                    find: jest.fn(),
                  },
                })),
              },
            },
          },
        },
        {
          provide: getRepositoryToken(ReportAction),
          useValue: {
            find: jest.fn(),
            findOne: jest.fn(),
            save: jest.fn(),
            update: jest.fn(),
            delete: jest.fn(),
            create: jest.fn(),
          },
        },
        {
          provide: DataSource,
          useValue: {
            transaction: jest.fn(),
          },
        },
        {
          provide: CacheService,
          useValue: {
            get: jest.fn(),
            set: jest.fn(),
            delete: jest.fn(),
            deleteKeysByPattern: jest.fn(),
          },
        },
        {
          provide: RabbitMQService,
          useValue: {
            sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
          },
        },
      ],
    }).compile();

    service = module.get<ReportsService>(ReportsService);
    dataSource = module.get<DataSource>(DataSource);
    cacheService = module.get<CacheService>(CacheService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('createReport', () => {
    it('should create a new report', async () => {
      const reporterId = '1';
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
        description: 'This is spam content',
        priority: 'medium',
      };

      const mockTransaction = jest.fn().mockImplementation(async (callback) => {
        return callback({
          save: jest.fn().mockResolvedValue(mockReport),
          update: jest.fn(),
        });
      });

      jest.spyOn(dataSource, 'transaction').mockImplementation(mockTransaction);
      jest.spyOn(service as any, 'create').mockResolvedValue(mockReport);
      jest.spyOn(service as any, 'findOne').mockResolvedValue(mockReport);
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            save: jest.fn().mockResolvedValue(mockReport),
            update: jest.fn(),
          });
          // Call afterCreate lifecycle hook
          await (service as any).afterCreate(mockReport);
          return result;
        });

      const result = await service.createReport(reporterId, dto);

      expect(result).toBeDefined();
      expect(
        (service as any).rabbitMQService.sendDataToRabbitMQAsync,
      ).toHaveBeenCalledWith(
        'report_created',
        expect.objectContaining({
          reportId: mockReport.id,
          reporterId,
          reportableType: dto.reportableType,
          reportableId: dto.reportableId,
          reason: dto.reason,
          priority: dto.priority,
        }),
      );
    });

    it('should throw error if duplicate report exists', async () => {
      const reporterId = '1';
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
        description: 'This is spam content',
      };

      jest.spyOn(service as any, 'findOne').mockResolvedValue(mockReport);

      await expect(service.createReport(reporterId, dto)).rejects.toThrow(
        HttpException,
      );
    });
  });

  describe('updateReport', () => {
    it('should update a report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const dto: UpdateReportDto = {
        status: 'under_review',
        priority: 'high',
        moderatorId: '2',
      };

      jest.spyOn(service as any, 'findOne').mockResolvedValue(mockReport);
      jest.spyOn(service as any, 'update').mockResolvedValue(undefined);
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            save: jest.fn().mockResolvedValue(mockReport),
            update: jest.fn(),
          });
          // Call afterUpdate lifecycle hook
          await (service as any).afterUpdate(mockReport);
          return result;
        });

      const result = await service.updateReport(reportId, moderatorId, dto);

      expect(result).toBeDefined();
      expect(
        (service as any).rabbitMQService.sendDataToRabbitMQAsync,
      ).toHaveBeenCalledWith(
        'report_updated',
        expect.objectContaining({
          reportId,
          status: dto.status,
          moderatorId,
        }),
      );
    });

    it('should throw error if report not found', async () => {
      const reportId = 'nonexistent';
      const moderatorId = '2';
      const dto: UpdateReportDto = {
        status: 'under_review',
      };

      jest.spyOn(service as any, 'findOne').mockResolvedValue(null);

      await expect(
        service.updateReport(reportId, moderatorId, dto),
      ).rejects.toThrow(HttpException);
    });
  });

  describe('list', () => {
    it('should return paginated reports', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
        status: 'pending',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service as any, 'listOffset').mockResolvedValue(mockResult);

      const result = await service.list(dto);

      expect(result).toEqual({
        result: expect.arrayContaining([expect.any(Object)]),
        metaData: expect.objectContaining({
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        }),
      });
    });
  });

  describe('getById', () => {
    it('should return a report by ID', async () => {
      const reportId = '1';

      jest.spyOn(service as any, 'findById').mockResolvedValue(mockReport);

      const result = await service.getById(reportId);

      expect(result).toBeDefined();
    });

    it('should throw error if report not found', async () => {
      const reportId = 'nonexistent';

      jest
        .spyOn(service as any, 'findById')
        .mockRejectedValue(new HttpException('Not found', 404));

      await expect(service.getById(reportId)).rejects.toThrow(HttpException);
    });
  });

  describe('createReportAction', () => {
    it('should create a report action', async () => {
      const moderatorId = '2';
      const dto: CreateReportActionDto = {
        reportId: '1',
        action: 'content_removed',
        description: 'Content removed due to spam',
        notes: 'User warned about future violations',
      };

      jest.spyOn(service as any, 'findById').mockResolvedValue(mockReport);
      Object.defineProperty(service, 'reportActionRepository', {
        value: {
          create: jest.fn().mockReturnValue(mockReportAction),
        },
        writable: true,
      });
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            save: jest.fn().mockResolvedValue(mockReportAction),
            update: jest.fn(),
          });
          return result;
        });

      const result = await service.createReportAction(moderatorId, dto);

      expect(result).toBeDefined();
      expect(
        (service as any).rabbitMQService.sendDataToRabbitMQAsync,
      ).toHaveBeenCalledWith(
        'report_action_created',
        expect.objectContaining({
          reportId: dto.reportId,
          action: dto.action,
          moderatorId,
        }),
      );
    });

    it('should throw error if report not found', async () => {
      const moderatorId = '2';
      const dto: CreateReportActionDto = {
        reportId: 'nonexistent',
        action: 'content_removed',
      };

      jest.spyOn(service as any, 'findById').mockResolvedValue(null);

      await expect(
        service.createReportAction(moderatorId, dto),
      ).rejects.toThrow(HttpException);
    });
  });

  describe('getStats', () => {
    it('should return report statistics', async () => {
      const dto: ReportStatsDto = {
        status: 'pending',
        startDate: '2024-01-01T00:00:00Z',
        endDate: '2024-12-31T23:59:59Z',
      };

      jest.spyOn(cacheService, 'get').mockResolvedValue(null);
      jest.spyOn(cacheService, 'set').mockResolvedValue(undefined);
      Object.defineProperty(service, 'reportRepository', {
        value: {
          count: jest.fn().mockResolvedValue(5),
          createQueryBuilder: jest.fn(() => ({
            select: jest.fn().mockReturnThis(),
            where: jest.fn().mockReturnThis(),
            andWhere: jest.fn().mockReturnThis(),
            groupBy: jest.fn().mockReturnThis(),
            orderBy: jest.fn().mockReturnThis(),
            limit: jest.fn().mockReturnThis(),
            getRawMany: jest.fn().mockResolvedValue([]),
            getRawOne: jest.fn().mockResolvedValue({ nextScheduled: null }),
          })),
        },
        writable: true,
      });
      Object.defineProperty(service, 'cacheService', {
        value: {
          get: jest.fn().mockResolvedValue(null),
          set: jest.fn().mockResolvedValue(undefined),
        },
        writable: true,
      });

      const result = await service.getStats(dto);

      expect(result).toEqual({
        totalReports: 5,
        pendingReports: 5,
        underReviewReports: 5,
        resolvedReports: 5,
        dismissedReports: 5,
        escalatedReports: 5,
        reportsByStatus: {},
        reportsByPriority: {},
        reportsByType: {},
        reportsByReason: {},
        averageResolutionTime: 0,
        topReporters: [],
        topModerators: [],
        recentTrends: [],
      });
    });

    it('should return cached statistics', async () => {
      const dto: ReportStatsDto = {
        status: 'pending',
      };

      const cachedStats = {
        totalReports: 10,
        pendingReports: 5,
        underReviewReports: 3,
        resolvedReports: 2,
        dismissedReports: 0,
        escalatedReports: 0,
        reportsByStatus: { pending: 5, under_review: 3, resolved: 2 },
        reportsByPriority: { low: 2, medium: 5, high: 3 },
        reportsByType: { article: 8, comment: 2 },
        reportsByReason: { spam: 6, harassment: 4 },
        averageResolutionTime: 2.5,
        topReporters: [{ reporterId: '1', count: 3 }],
        topModerators: [{ moderatorId: '2', count: 5 }],
        recentTrends: [{ date: '2024-01-15', count: 2 }],
      };

      jest.spyOn(cacheService, 'get').mockResolvedValue(cachedStats);
      Object.defineProperty(service, 'cacheService', {
        value: {
          get: jest.fn().mockResolvedValue(cachedStats),
          set: jest.fn().mockResolvedValue(undefined),
        },
        writable: true,
      });

      const result = await service.getStats(dto);

      expect(result).toEqual(cachedStats);
    });
  });

  describe('assignReport', () => {
    it('should assign a report to a moderator', async () => {
      const reportId = '1';
      const moderatorId = '2';

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.assignReport(reportId, moderatorId);

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        moderatorId,
        status: REPORT_CONSTANTS.STATUS.UNDER_REVIEW,
        assignedAt: expect.any(Date),
      });
    });
  });

  describe('resolveReport', () => {
    it('should resolve a report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const resolution = {
        action: 'content_removed',
        resolution: 'resolved',
        resolutionDetails: 'Content removed and user warned',
        moderatorNotes: 'User warned about future violations',
      };

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.resolveReport(reportId, moderatorId, resolution);

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        ...resolution,
        status: REPORT_CONSTANTS.STATUS.RESOLVED,
        resolvedAt: expect.any(Date),
      });
    });
  });

  describe('dismissReport', () => {
    it('should dismiss a report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason = 'No violation found';

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.dismissReport(reportId, moderatorId, reason);

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        status: REPORT_CONSTANTS.STATUS.DISMISSED,
        action: REPORT_CONSTANTS.ACTIONS.REPORT_DISMISSED,
        resolution: REPORT_CONSTANTS.RESOLUTION.DISMISSED,
        resolutionDetails: reason,
        resolvedAt: expect.any(Date),
      });
    });
  });

  describe('escalateReport', () => {
    it('should escalate a report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason = 'Requires admin review';

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.escalateReport(reportId, moderatorId, reason);

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        status: REPORT_CONSTANTS.STATUS.ESCALATED,
        action: REPORT_CONSTANTS.ACTIONS.ESCALATED_TO_ADMIN,
        resolution: REPORT_CONSTANTS.RESOLUTION.ESCALATED,
        resolutionDetails: reason,
      });
    });
  });

  describe('getReportsForContent', () => {
    it('should return reports for specific content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockResolvedValue([mockReport]),
        },
        writable: true,
      });

      const result = await service.getReportsForContent(reportableType, reportableId);

      expect(result).toEqual([mockReport]);
    });
  });

  describe('getDuplicateReports', () => {
    it('should return duplicate reports for content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockResolvedValue([mockReport]),
        },
        writable: true,
      });

      const result = await service.getDuplicateReports(reportableType, reportableId);

      expect(result).toEqual([mockReport]);
    });
  });

  describe('mergeDuplicateReports', () => {
    it('should merge duplicate reports', async () => {
      const reportIds = ['1', '2', '3'];
      const moderatorId = '2';

      const mockReports = [
        { ...mockReport, id: '1', createdAt: new Date('2024-01-01') },
        { ...mockReport, id: '2', createdAt: new Date('2024-01-02') },
        { ...mockReport, id: '3', createdAt: new Date('2024-01-03') },
      ];

      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockResolvedValue(mockReports),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            save: jest.fn().mockResolvedValue(mockReport),
            update: jest.fn(),
          });
          return result;
        });

      const result = await service.mergeDuplicateReports(reportIds, moderatorId);

      expect(result).toBeDefined();
    });

    it('should throw error if insufficient reports to merge', async () => {
      const reportIds = ['1'];
      const moderatorId = '2';

      await expect(
        service.mergeDuplicateReports(reportIds, moderatorId),
      ).rejects.toThrow(HttpException);
    });
  });
});
