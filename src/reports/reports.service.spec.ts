import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { DataSource } from 'typeorm';
import { ReportsService } from './reports.service';
import { Report } from './entities/report.entity';
import { ReportAction } from './entities/report-action.entity';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { QueryReportsDto } from './dto/query-reports.dto';
import { CreateReportActionDto } from './dto/create-report-action.dto';
import { ReportStatsDto } from './dto/report-stats.dto';
import { CacheService, RabbitMQService } from 'src/shared/services';
import { HttpException, HttpStatus } from '@nestjs/common';
import { REPORT_CONSTANTS } from 'src/shared/constants';

describe('ReportsService', () => {
  let service: ReportsService;
  let dataSource: DataSource;
  let cacheService: CacheService;

  const mockReport = {
    id: '1',
    userId: '1',
    user: {
      id: '1',
      username: 'testuser',
      displayName: 'Test User',
      avatar: 'avatar.jpg',
    },
    reportableType: 'article',
    reportableId: '1',
    reason: 'spam',
    description: 'This is spam content',
    status: REPORT_CONSTANTS.STATUS.PENDING,
    priority: 'medium',
    moderatorId: null,
    moderator: null,
    action: null,
    moderatorNotes: null,
    resolution: null,
    resolutionDetails: null,
    assignedAt: null,
    resolvedAt: null,
    duplicateCount: 1,
    isAutoGenerated: false,
    metadata: {},
    actions: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  } as unknown as Report;

  const mockReportAction = {
    id: '1',
    reportId: '1',
    report: mockReport,
    moderatorId: '2',
    moderator: {
      id: '2',
      username: 'moderator',
      displayName: 'Moderator',
    },
    action: 'content_removed',
    description: 'Content removed due to spam',
    notes: 'User warned about future violations',
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
  } as unknown as ReportAction;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ReportsService,
        {
          provide: getRepositoryToken(Report),
          useValue: {
            findOne: jest.fn(),
            save: jest.fn(),
            update: jest.fn(),
            findAndCount: jest.fn(),
            find: jest.fn(),
            count: jest.fn(),
            createQueryBuilder: jest.fn(() => ({
              select: jest.fn().mockReturnThis(),
              where: jest.fn().mockReturnThis(),
              andWhere: jest.fn().mockReturnThis(),
              groupBy: jest.fn().mockReturnThis(),
              orderBy: jest.fn().mockReturnThis(),
              limit: jest.fn().mockReturnThis(),
              getRawMany: jest.fn(),
              getRawOne: jest.fn(),
            })),
            metadata: {
              columns: [{ propertyName: 'deletedAt' }],
            },
            manager: {
              connection: {
                createQueryRunner: jest.fn(() => ({
                  connect: jest.fn(),
                  startTransaction: jest.fn(),
                  commitTransaction: jest.fn(),
                  rollbackTransaction: jest.fn(),
                  release: jest.fn(),
                  manager: {
                    save: jest.fn(),
                    update: jest.fn(),
                    findOne: jest.fn(),
                    delete: jest.fn(),
                    find: jest.fn(),
                  },
                })),
              },
            },
          },
        },
        {
          provide: getRepositoryToken(ReportAction),
          useValue: {
            find: jest.fn(),
            findOne: jest.fn(),
            save: jest.fn(),
            update: jest.fn(),
            delete: jest.fn(),
            create: jest.fn(),
          },
        },
        {
          provide: DataSource,
          useValue: {
            transaction: jest.fn(),
          },
        },
        {
          provide: CacheService,
          useValue: {
            get: jest.fn(),
            set: jest.fn(),
            delete: jest.fn(),
            deleteKeysByPattern: jest.fn(),
          },
        },
        {
          provide: RabbitMQService,
          useValue: {
            sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
          },
        },
      ],
    }).compile();

    service = module.get<ReportsService>(ReportsService);
    dataSource = module.get<DataSource>(DataSource);
    cacheService = module.get<CacheService>(CacheService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('createReport', () => {
    it('should create a new report successfully', async () => {
      const userId = '1';
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
        description: 'This is spam content',
        priority: 'medium',
      };

      const mockTransaction = jest.fn().mockImplementation(async (callback) => {
        return callback({
          save: jest.fn().mockResolvedValue(mockReport),
          update: jest.fn(),
        });
      });

      jest.spyOn(dataSource, 'transaction').mockImplementation(mockTransaction);
      jest.spyOn(service as any, 'create').mockResolvedValue(mockReport);
      jest.spyOn(service as any, 'findOne').mockResolvedValue(mockReport);
      jest.spyOn(service as any, 'getDuplicateReports').mockResolvedValue([]);
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            manager: {
              save: jest.fn().mockResolvedValue(mockReport),
              update: jest.fn(),
              find: jest.fn(),
            },
          });
          // Call afterCreate lifecycle hook
          await (service as any).afterCreate(mockReport);
          return result;
        });

      const result = await service.createReport(userId, dto);

      expect(result).toBeDefined();
      expect(
        (service as any).rabbitMQService.sendDataToRabbitMQAsync,
      ).toHaveBeenCalledWith(
        'report_created',
        expect.objectContaining({
          reportId: mockReport.id,
          userId,
          reportableType: dto.reportableType,
          reportableId: dto.reportableId,
          reason: dto.reason,
          priority: dto.priority,
        }),
      );
    });

    it('should create report with auto-generated flag', async () => {
      const userId = '1';
      const dto: CreateReportDto = {
        reportableType: 'comment',
        reportableId: '2',
        reason: 'hate_speech',
        description: 'Automatically detected hate speech',
        isAutoGenerated: true,
        priority: 'high',
      };

      const autoGeneratedReport = { ...mockReport, isAutoGenerated: true };
      jest
        .spyOn(service as any, 'create')
        .mockResolvedValue(autoGeneratedReport);
      jest
        .spyOn(service as any, 'findOne')
        .mockResolvedValue(autoGeneratedReport);
      jest.spyOn(service as any, 'getDuplicateReports').mockResolvedValue([]);
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            manager: {
              save: jest.fn().mockResolvedValue(autoGeneratedReport),
              update: jest.fn(),
              find: jest.fn(),
            },
          });
          await (service as any).afterCreate(autoGeneratedReport);
          return result;
        });

      const result = await service.createReport(userId, dto);

      expect(result).toBeDefined();
      expect(result.isAutoGenerated).toBe(true);
    });

    it('should throw error if duplicate report exists', async () => {
      const userId = '1';
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
        description: 'This is spam content',
      };

      jest.spyOn(service as any, 'findOne').mockResolvedValue(mockReport);

      await expect(service.createReport(userId, dto)).rejects.toThrow(
        HttpException,
      );
    });

    it('should handle service errors when creating report', async () => {
      const userId = '1';
      const dto: CreateReportDto = {
        reportableType: 'article',
        reportableId: '1',
        reason: 'spam',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service as any, 'runInTransaction').mockRejectedValue(error);

      await expect(service.createReport(userId, dto)).rejects.toThrow(error);
    });
  });

  describe('updateReport', () => {
    it('should update a report successfully', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const dto: UpdateReportDto = {
        status: REPORT_CONSTANTS.STATUS.UNDER_REVIEW,
        priority: 'high',
        moderatorId: '2',
      };

      jest.spyOn(service as any, 'findOne').mockResolvedValue(mockReport);
      jest.spyOn(service as any, 'update').mockResolvedValue(undefined);
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      const updatedReport = { ...mockReport, ...dto };
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            manager: {
              save: jest.fn().mockResolvedValue(updatedReport),
              update: jest.fn(),
              find: jest.fn(),
            },
          });
          // Call afterUpdate lifecycle hook
          await (service as any).afterUpdate(updatedReport);
          return result;
        });

      const result = await service.updateReport(reportId, moderatorId, dto);

      expect(result).toBeDefined();
      expect(
        (service as any).rabbitMQService.sendDataToRabbitMQAsync,
      ).toHaveBeenCalledWith(
        'report_updated',
        expect.objectContaining({
          reportId,
          status: dto.status,
          moderatorId,
        }),
      );
    });

    it('should update report with resolution details', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const dto: UpdateReportDto = {
        status: REPORT_CONSTANTS.STATUS.RESOLVED,
        action: REPORT_CONSTANTS.ACTIONS.CONTENT_REMOVED,
        resolution: REPORT_CONSTANTS.RESOLUTION.RESOLVED,
        resolutionDetails: 'Content removed and user warned',
        moderatorNotes: 'User warned about future violations',
        resolvedAt: new Date(),
      };

      const resolvedReport = {
        ...mockReport,
        status: REPORT_CONSTANTS.STATUS.RESOLVED,
        action: 'content_removed',
      };
      jest.spyOn(service as any, 'findOne').mockResolvedValue(resolvedReport);
      jest.spyOn(service as any, 'update').mockResolvedValue(undefined);
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            manager: {
              save: jest.fn().mockResolvedValue(resolvedReport),
              update: jest.fn(),
              find: jest.fn(),
            },
          });
          await (service as any).afterUpdate(resolvedReport);
          return result;
        });

      const result = await service.updateReport(reportId, moderatorId, dto);

      expect(result).toBeDefined();
      expect(result.status).toBe('resolved');
      expect(result.action).toBe('content_removed');
    });

    it('should throw error if report not found', async () => {
      const reportId = 'nonexistent';
      const moderatorId = '2';
      const dto: UpdateReportDto = {
        status: REPORT_CONSTANTS.STATUS.UNDER_REVIEW,
      };

      jest.spyOn(service as any, 'findOne').mockResolvedValue(null);

      await expect(
        service.updateReport(reportId, moderatorId, dto),
      ).rejects.toThrow(HttpException);
    });

    it('should handle service errors when updating report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const dto: UpdateReportDto = {
        status: REPORT_CONSTANTS.STATUS.UNDER_REVIEW,
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service as any, 'runInTransaction').mockRejectedValue(error);

      await expect(
        service.updateReport(reportId, moderatorId, dto),
      ).rejects.toThrow(error);
    });
  });

  describe('list', () => {
    it('should return paginated reports with filters', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
        status: REPORT_CONSTANTS.STATUS.PENDING,
        priority: 'high',
        reportableType: 'article',
        reason: 'spam',
      };

      const mockResult = {
        result: [mockReport],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        },
      };

      jest.spyOn(service as any, 'listOffset').mockResolvedValue(mockResult);

      const result = await service.list(dto);

      expect(result).toEqual({
        result: expect.arrayContaining([expect.any(Object)]),
        metaData: expect.objectContaining({
          currentPage: 1,
          pageSize: 10,
          totalRecords: 1,
          totalPages: 1,
          hasNextPage: false,
        }),
      });
    });

    it('should return empty result when no reports found', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
        status: REPORT_CONSTANTS.STATUS.RESOLVED,
      };

      const mockResult = {
        result: [],
        metaData: {
          currentPage: 1,
          pageSize: 10,
          totalRecords: 0,
          totalPages: 0,
          hasNextPage: false,
        },
      };

      jest.spyOn(service as any, 'listOffset').mockResolvedValue(mockResult);

      const result = await service.list(dto);

      expect(result).toEqual(mockResult);
      expect(result.result).toHaveLength(0);
    });

    it('should handle service errors when listing reports', async () => {
      const dto: QueryReportsDto = {
        page: 1,
        limit: 10,
        sortBy: 'createdAt',
        order: 'DESC',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service as any, 'listOffset').mockRejectedValue(error);

      await expect(service.list(dto)).rejects.toThrow(error);
    });
  });

  describe('getById', () => {
    it('should return a report by ID with relations', async () => {
      const reportId = '1';

      jest.spyOn(service as any, 'findById').mockResolvedValue(mockReport);

      const result = await service.getById(reportId);

      expect(result).toBeDefined();
      expect(service.findById).toHaveBeenCalledWith(reportId, {
        relations: ['user', 'moderator', 'actions', 'actions.moderator'],
      });
    });

    it('should throw error if report not found', async () => {
      const reportId = 'nonexistent';

      jest
        .spyOn(service as any, 'findById')
        .mockRejectedValue(new HttpException('Not found', 404));

      await expect(service.getById(reportId)).rejects.toThrow(HttpException);
    });

    it('should handle service errors when getting report by ID', async () => {
      const reportId = '1';

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service as any, 'findById').mockRejectedValue(error);

      await expect(service.getById(reportId)).rejects.toThrow(error);
    });
  });

  describe('createReportAction', () => {
    it('should create a report action successfully', async () => {
      const moderatorId = '2';
      const dto: CreateReportActionDto = {
        reportId: '1',
        action: 'content_removed',
        description: 'Content removed due to spam',
        notes: 'User warned about future violations',
      };

      jest.spyOn(service as any, 'findById').mockResolvedValue(mockReport);
      Object.defineProperty(service, 'reportActionRepository', {
        value: {
          create: jest.fn().mockReturnValue(mockReportAction),
        },
        writable: true,
      });
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            manager: {
              save: jest.fn().mockResolvedValue(mockReportAction),
              update: jest.fn(),
              find: jest.fn(),
            },
          });
          return result;
        });

      const result = await service.createReportAction(moderatorId, dto);

      expect(result).toBeDefined();
      expect(
        (service as any).rabbitMQService.sendDataToRabbitMQAsync,
      ).toHaveBeenCalledWith(
        'report_action_created',
        expect.objectContaining({
          reportId: dto.reportId,
          action: dto.action,
          moderatorId,
        }),
      );
    });

    it('should create report action with metadata', async () => {
      const moderatorId = '2';
      const dto: CreateReportActionDto = {
        reportId: '1',
        action: REPORT_CONSTANTS.ACTIONS.USER_WARNED,
        description: 'User warned about inappropriate behavior',
        notes: 'First warning issued',
        metadata: {
          warningLevel: 1,
          previousWarnings: 0,
          contentId: '123',
        },
      };

      const actionWithMetadata = {
        ...mockReportAction,
        metadata: dto.metadata,
      };
      jest.spyOn(service as any, 'findById').mockResolvedValue(mockReport);
      Object.defineProperty(service, 'reportActionRepository', {
        value: {
          create: jest.fn().mockReturnValue(actionWithMetadata),
        },
        writable: true,
      });
      Object.defineProperty(service, 'rabbitMQService', {
        value: {
          sendDataToRabbitMQAsync: jest.fn().mockResolvedValue(true),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            manager: {
              save: jest.fn().mockResolvedValue(actionWithMetadata),
              update: jest.fn(),
              find: jest.fn(),
            },
          });
          return result;
        });

      const result = await service.createReportAction(moderatorId, dto);

      expect(result).toBeDefined();
      expect(result.metadata).toEqual(dto.metadata);
    });

    it('should throw error if report not found', async () => {
      const moderatorId = '2';
      const dto: CreateReportActionDto = {
        reportId: 'nonexistent',
        action: 'content_removed',
      };

      jest.spyOn(service as any, 'findById').mockResolvedValue(null);

      await expect(
        service.createReportAction(moderatorId, dto),
      ).rejects.toThrow(HttpException);
    });

    it('should handle service errors when creating report action', async () => {
      const moderatorId = '2';
      const dto: CreateReportActionDto = {
        reportId: '1',
        action: 'content_removed',
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(service as any, 'runInTransaction').mockRejectedValue(error);

      await expect(
        service.createReportAction(moderatorId, dto),
      ).rejects.toThrow(error);
    });
  });

  describe('getStats', () => {
    it('should return report statistics with filters', async () => {
      const dto: ReportStatsDto = {
        status: REPORT_CONSTANTS.STATUS.PENDING,
        startDate: '2024-01-01T00:00:00Z',
        endDate: '2024-12-31T23:59:59Z',
        groupBy: 'day',
      };

      jest.spyOn(cacheService, 'get').mockResolvedValue(null);
      jest.spyOn(cacheService, 'set').mockResolvedValue(undefined);
      Object.defineProperty(service, 'reportRepository', {
        value: {
          count: jest.fn().mockResolvedValue(5),
          find: jest.fn().mockResolvedValue([]),
          createQueryBuilder: jest.fn(() => ({
            select: jest.fn().mockReturnThis(),
            where: jest.fn().mockReturnThis(),
            andWhere: jest.fn().mockReturnThis(),
            groupBy: jest.fn().mockReturnThis(),
            orderBy: jest.fn().mockReturnThis(),
            limit: jest.fn().mockReturnThis(),
            getRawMany: jest.fn().mockResolvedValue([]),
            getRawOne: jest.fn().mockResolvedValue({ nextScheduled: null }),
          })),
        },
        writable: true,
      });
      Object.defineProperty(service, 'cacheService', {
        value: {
          get: jest.fn().mockResolvedValue(null),
          set: jest.fn().mockResolvedValue(undefined),
        },
        writable: true,
      });

      const result = await service.getStats(dto);

      expect(result).toEqual({
        totalReports: 5,
        pendingReports: 5,
        underReviewReports: 5,
        resolvedReports: 5,
        dismissedReports: 5,
        escalatedReports: 5,
        reportsByStatus: {},
        reportsByPriority: {},
        reportsByType: {},
        reportsByReason: {},
        averageResolutionTime: 0,
        topUsers: [],
        topModerators: [],
        recentTrends: [],
      });
    });

    it('should return cached statistics', async () => {
      const dto: ReportStatsDto = {
        status: REPORT_CONSTANTS.STATUS.PENDING,
      };

      const cachedStats = {
        totalReports: 10,
        pendingReports: 5,
        underReviewReports: 3,
        resolvedReports: 2,
        dismissedReports: 0,
        escalatedReports: 0,
        reportsByStatus: { pending: 5, under_review: 3, resolved: 2 },
        reportsByPriority: { low: 2, medium: 5, high: 3 },
        reportsByType: { article: 8, comment: 2 },
        reportsByReason: { spam: 6, harassment: 4 },
        averageResolutionTime: 2.5,
        topUsers: [{ userId: '1', count: 3 }],
        topModerators: [{ moderatorId: '2', count: 5 }],
        recentTrends: [{ date: '2024-01-15', count: 2 }],
      };

      jest.spyOn(cacheService, 'get').mockResolvedValue(cachedStats);
      Object.defineProperty(service, 'cacheService', {
        value: {
          get: jest.fn().mockResolvedValue(cachedStats),
          set: jest.fn().mockResolvedValue(undefined),
        },
        writable: true,
      });

      const result = await service.getStats(dto);

      expect(result).toEqual(cachedStats);
    });

    it('should handle service errors when getting statistics', async () => {
      const dto: ReportStatsDto = {
        status: REPORT_CONSTANTS.STATUS.PENDING,
      };

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      jest.spyOn(cacheService, 'get').mockResolvedValue(null);
      Object.defineProperty(service, 'reportRepository', {
        value: {
          count: jest.fn().mockRejectedValue(error),
          find: jest.fn().mockRejectedValue(error),
          findOne: jest.fn().mockRejectedValue(error),
          save: jest.fn().mockRejectedValue(error),
          update: jest.fn().mockRejectedValue(error),
          findAndCount: jest.fn().mockRejectedValue(error),
        },
        writable: true,
      });

      await expect(service.getStats(dto)).rejects.toThrow(error);
    });
  });

  describe('assignReport', () => {
    it('should assign a report to a moderator successfully', async () => {
      const reportId = '1';
      const moderatorId = '2';

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.assignReport(reportId, moderatorId);

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        moderatorId,
        status: REPORT_CONSTANTS.STATUS.UNDER_REVIEW,
        assignedAt: expect.any(Date),
      });
    });

    it('should handle service errors when assigning report', async () => {
      const reportId = '1';
      const moderatorId = '2';

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'updateReport').mockRejectedValue(error);

      await expect(service.assignReport(reportId, moderatorId)).rejects.toThrow(
        error,
      );
    });
  });

  describe('resolveReport', () => {
    it('should resolve a report successfully', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const resolution = {
        action: REPORT_CONSTANTS.ACTIONS.CONTENT_REMOVED,
        resolution: REPORT_CONSTANTS.RESOLUTION.RESOLVED,
        resolutionDetails: 'Content removed and user warned',
        moderatorNotes: 'User warned about future violations',
      };

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.resolveReport(
        reportId,
        moderatorId,
        resolution,
      );

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        ...resolution,
        status: REPORT_CONSTANTS.STATUS.RESOLVED,
        resolvedAt: expect.any(Date),
      });
    });

    it('should resolve report with minimal data', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const resolution = {
        action: REPORT_CONSTANTS.ACTIONS.NO_ACTION,
        resolution: REPORT_CONSTANTS.RESOLUTION.DISMISSED,
      };

      const resolvedReport = {
        ...mockReport,
        status: REPORT_CONSTANTS.STATUS.RESOLVED,
        isPending: () => false,
        isUnderReview: () => false,
        isResolved: () => true,
        isDismissed: () => false,
        isEscalated: () => false,
        isHighPriority: () => false,
        isUrgent: () => false,
        getAgeInDays: () => 1,
        isExpired: () => false,
      };
      jest
        .spyOn(service, 'updateReport')
        .mockResolvedValue(resolvedReport as any);

      const result = await service.resolveReport(
        reportId,
        moderatorId,
        resolution,
      );

      expect(result).toBeDefined();
      expect(result.status).toBe('resolved');
    });

    it('should handle service errors when resolving report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const resolution = {
        action: REPORT_CONSTANTS.ACTIONS.CONTENT_REMOVED,
        resolution: REPORT_CONSTANTS.RESOLUTION.RESOLVED,
      };

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'updateReport').mockRejectedValue(error);

      await expect(
        service.resolveReport(reportId, moderatorId, resolution),
      ).rejects.toThrow(error);
    });
  });

  describe('dismissReport', () => {
    it('should dismiss a report successfully', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason = 'No violation found';

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.dismissReport(reportId, moderatorId, reason);

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        status: REPORT_CONSTANTS.STATUS.DISMISSED,
        action: REPORT_CONSTANTS.ACTIONS.REPORT_DISMISSED,
        resolution: REPORT_CONSTANTS.RESOLUTION.DISMISSED,
        resolutionDetails: reason,
        resolvedAt: expect.any(Date),
      });
    });

    it('should dismiss report with detailed reason', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason =
        'Content does not violate community guidelines. User was expressing legitimate opinion.';

      const dismissedReport = {
        ...mockReport,
        status: REPORT_CONSTANTS.STATUS.DISMISSED,
        isPending: () => false,
        isUnderReview: () => false,
        isResolved: () => false,
        isDismissed: () => true,
        isEscalated: () => false,
        isHighPriority: () => false,
        isUrgent: () => false,
        getAgeInDays: () => 1,
        isExpired: () => false,
      };
      jest
        .spyOn(service, 'updateReport')
        .mockResolvedValue(dismissedReport as any);

      const result = await service.dismissReport(reportId, moderatorId, reason);

      expect(result).toBeDefined();
      expect(result.status).toBe('dismissed');
    });

    it('should handle service errors when dismissing report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason = 'No violation found';

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'updateReport').mockRejectedValue(error);

      await expect(
        service.dismissReport(reportId, moderatorId, reason),
      ).rejects.toThrow(error);
    });
  });

  describe('escalateReport', () => {
    it('should escalate a report successfully', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason = 'Requires admin review';

      jest.spyOn(service, 'updateReport').mockResolvedValue(mockReport);

      const result = await service.escalateReport(
        reportId,
        moderatorId,
        reason,
      );

      expect(result).toBeDefined();
      expect(service.updateReport).toHaveBeenCalledWith(reportId, moderatorId, {
        status: REPORT_CONSTANTS.STATUS.ESCALATED,
        action: REPORT_CONSTANTS.ACTIONS.ESCALATED_TO_ADMIN,
        resolution: REPORT_CONSTANTS.RESOLUTION.ESCALATED,
        resolutionDetails: reason,
      });
    });

    it('should escalate report with detailed reason', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason =
        'Complex case involving multiple violations. Requires senior moderator review and potential legal consultation.';

      const escalatedReport = {
        ...mockReport,
        status: REPORT_CONSTANTS.STATUS.ESCALATED,
        isPending: () => false,
        isUnderReview: () => false,
        isResolved: () => false,
        isDismissed: () => false,
        isEscalated: () => true,
        isHighPriority: () => false,
        isUrgent: () => false,
        getAgeInDays: () => 1,
        isExpired: () => false,
      };
      jest
        .spyOn(service, 'updateReport')
        .mockResolvedValue(escalatedReport as any);

      const result = await service.escalateReport(
        reportId,
        moderatorId,
        reason,
      );

      expect(result).toBeDefined();
      expect(result.status).toBe('escalated');
    });

    it('should handle service errors when escalating report', async () => {
      const reportId = '1';
      const moderatorId = '2';
      const reason = 'Requires admin review';

      const error = new HttpException('Report not found', HttpStatus.NOT_FOUND);
      jest.spyOn(service, 'updateReport').mockRejectedValue(error);

      await expect(
        service.escalateReport(reportId, moderatorId, reason),
      ).rejects.toThrow(error);
    });
  });

  describe('getReportsForContent', () => {
    it('should return reports for specific content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockResolvedValue([mockReport]),
        },
        writable: true,
      });

      const result = await service.getReportsForContent(
        reportableType,
        reportableId,
      );

      expect(result).toEqual([mockReport]);
    });

    it('should return empty array when no reports found for content', async () => {
      const reportableType = 'comment';
      const reportableId = '999';

      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockResolvedValue([]),
        },
        writable: true,
      });

      const result = await service.getReportsForContent(
        reportableType,
        reportableId,
      );

      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });

    it('should handle service errors when getting reports for content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      const error = new HttpException(
        'Database error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockRejectedValue(error),
        },
        writable: true,
      });

      await expect(
        service.getReportsForContent(reportableType, reportableId),
      ).rejects.toThrow(error);
    });
  });

  describe('getDuplicateReports', () => {
    it('should return duplicate reports for content', async () => {
      const reportableType = 'article';
      const reportableId = '1';

      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockResolvedValue([mockReport]),
        },
        writable: true,
      });

      const result = await service.getDuplicateReports(
        reportableType,
        reportableId,
      );

      expect(result).toEqual([mockReport]);
    });
  });

  describe('mergeDuplicateReports', () => {
    it('should merge duplicate reports', async () => {
      const reportIds = ['1', '2', '3'];
      const moderatorId = '2';

      const mockReports = [
        { ...mockReport, id: '1', createdAt: new Date('2024-01-01') },
        { ...mockReport, id: '2', createdAt: new Date('2024-01-02') },
        { ...mockReport, id: '3', createdAt: new Date('2024-01-03') },
      ];

      Object.defineProperty(service, 'reportRepository', {
        value: {
          find: jest.fn().mockResolvedValue(mockReports),
        },
        writable: true,
      });
      jest
        .spyOn(service as any, 'runInTransaction')
        .mockImplementation(async (callback: any) => {
          const result = await callback({
            manager: {
              save: jest.fn().mockResolvedValue(mockReport),
              update: jest.fn(),
              find: jest.fn().mockResolvedValue(mockReports),
            },
          });
          return result;
        });

      const result = await service.mergeDuplicateReports(
        reportIds,
        moderatorId,
      );

      expect(result).toBeDefined();
    });

    it('should throw error if insufficient reports to merge', async () => {
      const reportIds = ['1'];
      const moderatorId = '2';

      await expect(
        service.mergeDuplicateReports(reportIds, moderatorId),
      ).rejects.toThrow(HttpException);
    });
  });
});
