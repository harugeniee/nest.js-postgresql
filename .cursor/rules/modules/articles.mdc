---
alwaysApply: false
---
@rule articles_contract
Entity `Article` (current implementation):
- title (varchar 256), slug (unique), content (text), summary (text), contentFormat (enum), visibility (enum), status (enum)
- userId (bigint FK), coverImageId (bigint FK), organizationId (bigint FK)
- scheduledAt, publishedAt (timestamps), wordCount, readTimeMinutes (int)
- viewsCount, likesCount, bookmarksCount, commentsCount (int, default 0)
- tagsArray (json), authors (many-to-many), tags (many-to-many)
- indexes: slug unique, (userId, createdAt), (status, scheduledAt), (visibility, status)

Service config:
- entityName: 'Article'; cache: { prefix: 'articles', ttlSec: 60, swrSec: 30 }
- defaultSearchField: 'title'
- getSearchableColumns(): ['title','summary','content']
- relationsWhitelist: { user: { avatar: true }, tags: true, coverImage: true, authors: { avatar: true } }
- selectWhitelist: { id:true, title:true, slug:true, user:{ id:true, username:true } }

Controller routes:
- GET /articles -> listOffset or listCursor
- GET /articles/:id -> findById(SnowflakeIdPipe)
- GET /articles/slug/:slug -> findBySlug
- POST /articles -> @Auth() createArticle
- PATCH /articles/:id -> @Auth() updateArticle
- DELETE /articles/:id -> @Auth(['admin']) remove
- POST /articles/:id/schedule -> @Auth() scheduleArticle
- POST /articles/:id/publish -> @Auth() publishScheduledArticle

@acceptance
- [ ] Controller has no domain logic.
- [ ] Signed cursor only; no offset leak.
- [ ] Cache invalidated on write; list:* and id:ID keys cleared.
- [ ] Slug generation with collision avoidance.
- [ ] Scheduled publishing with proper status management.
- [ ] Co-authors support with proper validation.@rule articles_contract
Entity `Article` (current implementation):
- title (varchar 256), slug (unique), content (text), summary (text), contentFormat (enum), visibility (enum), status (enum)
- userId (bigint FK), coverImageId (bigint FK), organizationId (bigint FK)
- scheduledAt, publishedAt (timestamps), wordCount, readTimeMinutes (int)
- viewsCount, likesCount, bookmarksCount, commentsCount (int, default 0)
- tagsArray (json), authors (many-to-many), tags (many-to-many)
- indexes: slug unique, (userId, createdAt), (status, scheduledAt), (visibility, status)

Service config:
- entityName: 'Article'; cache: { prefix: 'articles', ttlSec: 60, swrSec: 30 }
- defaultSearchField: 'title'
- getSearchableColumns(): ['title','summary','content']
- relationsWhitelist: { user: { avatar: true }, tags: true, coverImage: true, authors: { avatar: true } }
- selectWhitelist: { id:true, title:true, slug:true, user:{ id:true, username:true } }

Controller routes:
- GET /articles -> listOffset or listCursor
- GET /articles/:id -> findById(SnowflakeIdPipe)
- GET /articles/slug/:slug -> findBySlug
- POST /articles -> @Auth() createArticle
- PATCH /articles/:id -> @Auth() updateArticle
- DELETE /articles/:id -> @Auth(['admin']) remove
- POST /articles/:id/schedule -> @Auth() scheduleArticle
- POST /articles/:id/publish -> @Auth() publishScheduledArticle

@acceptance
- [ ] Controller has no domain logic.
- [ ] Signed cursor only; no offset leak.
- [ ] Cache invalidated on write; list:* and id:ID keys cleared.
- [ ] Slug generation with collision avoidance.
- [ ] Scheduled publishing with proper status management.
- [ ] Co-authors support with proper validation.